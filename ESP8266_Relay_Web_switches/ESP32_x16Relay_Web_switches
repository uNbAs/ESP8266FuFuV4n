// Aumentar el límite de tamaño de POST a 1.5 MB (suficiente para la mayoría de firmwares)
#define HTTP_MAX_POST_SIZE 1572864 // 1.5 MB
#include <WiFi.h>
#include <WebServer.h>
#include <Update.h>

// --- Credenciales WiFi ---
const char* ssid = "SSID";
const char* password = "PASSWORD";

// --- Credenciales para OTA (usuario y contraseña) ---
const char* OTA_USER = "admin";
const char* OTA_PASS = "admin";

// --- Pines para el 74HC595 ---
const int DATA_PIN = 14;
const int CLOCK_PIN = 13;
const int LATCH_PIN = 12;
const int OE_PIN = 5;

// --- Variables de estado de los relés (16 en total) ---
bool relayStates[16] = {false};

// --- Nombres personalizados para los primeros 6 relés ---
const char* deviceNames[6] = {
  "Luz Interior",
  "Luz Exterior",
  "Aguas Limpias",
  "Aguas Sucias",
  "Calentador",
  "Inversor"
};

// ================= NUEVO: MAPEO DISPOSITIVO -> RELÉ FÍSICO =================
// Indica qué relé (índice 0-15) controla cada dispositivo (índice 0-5)
// Dispositivo 0 (Luz Interior) -> Relé 1  (índice 0)
// Dispositivo 1 (Luz Exterior) -> Relé 9  (índice 8)
// Dispositivo 2 (Aguas Limpias) -> Relé 2  (índice 1)
// Dispositivo 3 (Aguas Sucias)  -> Relé 10 (índice 9)
// Dispositivo 4 (Calentador)    -> Relé 3  (índice 2)
// Dispositivo 5 (Inversor)      -> Relé 11 (índice 10)
const int deviceToRelay[6] = {0, 15, 1, 14, 2, 13};
// ============================================================================

// --- Servidor web ---
WebServer server(80);

// --- Bandera para evitar múltiples respuestas OTA ---
bool otaResponseSent = false;

//==============================================================================
// FUNCIÓN: Actualizar los registros 74HC595
//==============================================================================
void actualizarRegistros() {
  uint8_t lowByte = 0;
  uint8_t highByte = 0;

  for (int i = 0; i < 8; i++) {
    if (relayStates[i]) bitSet(lowByte, i);
    if (relayStates[i + 8]) bitSet(highByte, i);
  }

  digitalWrite(LATCH_PIN, LOW);
  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, highByte);
  shiftOut(DATA_PIN, CLOCK_PIN, MSBFIRST, lowByte);
  digitalWrite(LATCH_PIN, HIGH);
}

//==============================================================================
// MANEJADORES DE LA PÁGINA PRINCIPAL
//==============================================================================

void handleRoot() {
  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FuFuV4n</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #f4f4f9; margin: 20px; }
        h1 { color: #333; }
        .relay-grid { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr);
            gap: 15px; 
            max-width: 500px; 
            margin: 20px auto; 
        }
        .relay-card { background: white; border-radius: 10px; padding: 20px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); }
        .relay-name { font-size: 1.2em; margin-bottom: 15px; color: #555; }
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #2196F3; }
        input:checked + .slider:before { transform: translateX(26px); }
    </style>
</head>
<body>
    <h1>FuFuV4n Controller</h1>
    <div class="relay-grid">
)rawliteral";

  // Generar los 6 interruptores usando el mapeo deviceToRelay
  for (int i = 0; i < 6; i++) {
    int relayIdx = deviceToRelay[i];                // Índice del relé real
    String checked = relayStates[relayIdx] ? "checked" : "";
    html += "<div class='relay-card'>";
    html += "<div class='relay-name'>" + String(deviceNames[i]) + "</div>";
    html += "<label class='switch'>";
    // El número que se pasa a toggleDevice es el índice del dispositivo (1-6) para mantener claridad
    html += "<input type='checkbox' id='dev" + String(i+1) + "' " + checked + " onchange=\"toggleDevice(" + String(i+1) + ", this.checked)\">";
    html += "<span class='slider'></span>";
    html += "</label>";
    html += "</div>";
  }

  html += R"rawliteral(
    </div>
    <script>
        function toggleDevice(num, state) {
            fetch(`/device/${num}/${state ? 'on' : 'off'}`)
                .then(response => {
                    if (!response.ok) console.error('Error al cambiar estado');
                })
                .catch(error => console.error('Error de red:', error));
        }
    </script>
</body>
</html>
)rawliteral";

  server.send(200, "text/html", html);
}

//==============================================================================
// MANEJADOR PARA EL CONTROL DE DISPOSITIVOS (USA EL MAPEO)
//==============================================================================
void handleDevice() {
  String path = server.uri();
  int lastSlash = path.lastIndexOf('/');
  int secondLastSlash = path.lastIndexOf('/', lastSlash - 1);

  if (secondLastSlash > 0 && lastSlash > secondLastSlash) {
    String numStr = path.substring(secondLastSlash + 1, lastSlash);
    String action = path.substring(lastSlash + 1);
    int deviceIndex = numStr.toInt() - 1;  // Convertir a 0-5

    if (deviceIndex >= 0 && deviceIndex < 6) {
      int relayIdx = deviceToRelay[deviceIndex];  // Relé correspondiente

      if (action == "on") {
        relayStates[relayIdx] = true;
      } else if (action == "off") {
        relayStates[relayIdx] = false;
      } else {
        server.send(400, "text/plain", "Acci&oacute;n no v&aacute;lida");
        return;
      }
      actualizarRegistros();
      server.send(200, "text/plain", relayStates[relayIdx] ? "ON" : "OFF");
      return;
    }
  }
  server.send(404, "text/plain", "P&aacute;gina no encontrada");
}

//==============================================================================
// MANEJADORES PARA LA ACTUALIZACIÓN OTA VÍA WEB (PROTEGIDOS)
//==============================================================================

// Página con el formulario de subida (solicita autenticación) y log en tiempo real
void handleUpdateGet() {
  if (!server.authenticate(OTA_USER, OTA_PASS)) {
    return server.requestAuthentication();
  }

  String html = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Actualizaci&oacute;n OTA</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; background-color: #f4f4f9; margin: 20px; }
        h1 { color: #333; }
        form { background: white; padding: 20px; border-radius: 10px; display: inline-block; box-shadow: 0 4px 8px rgba(0,0,0,0.1); margin-bottom: 20px; }
        input[type=file] { margin: 10px; }
        input[type=button] { background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; }
        .log { background: #1e1e1e; color: #0f0; padding: 15px; border-radius: 5px; text-align: left; font-family: monospace; max-width: 600px; margin: 0 auto; height: 200px; overflow-y: auto; white-space: pre-wrap; }
        .back { margin-top: 20px; }
        .back a { color: #2196F3; text-decoration: none; }
        .progress { width: 100%; background-color: #ddd; border-radius: 5px; margin-top: 10px; display: none; }
        .progress-bar { width: 0%; height: 20px; background-color: #4CAF50; border-radius: 5px; text-align: center; color: white; line-height: 20px; }
    </style>
</head>
<body>
    <h1>Actualizar Firmware</h1>
    <div>
        <input type="file" id="firmwareFile" accept=".bin">
        <br>
        <input type="button" value="Subir y Actualizar" onclick="uploadFirmware()">
    </div>
    <div class="progress" id="progressContainer">
        <div class="progress-bar" id="progressBar">0%</div>
    </div>
    <div class="log" id="log">Listo para actualizar...</div>
    <div class="back">
        <a href="/">Volver al control</a>
    </div>
    <script>
        const logDiv = document.getElementById('log');
        const progressContainer = document.getElementById('progressContainer');
        const progressBar = document.getElementById('progressBar');
        const fileInput = document.getElementById('firmwareFile');
        const credentials = btoa('admin:esp32relay');

        function log(message) {
            logDiv.innerHTML += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function uploadFirmware() {
            const file = fileInput.files[0];
            if (!file) {
                log('Error: No se ha seleccionado ning&uacute;n archivo.');
                return;
            }

            log('Iniciando subida: ' + file.name);
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressBar.textContent = '0%';

            const xhr = new XMLHttpRequest();
            xhr.open('POST', '/update', true);
            xhr.setRequestHeader('Authorization', 'Basic ' + credentials);
            xhr.timeout = 120000; // 120 segundos de timeout

            xhr.upload.addEventListener('progress', function(e) {
                if (e.lengthComputable) {
                    const percent = Math.round((e.loaded / e.total) * 100);
                    progressBar.style.width = percent + '%';
                    progressBar.textContent = percent + '%';
                    log('Subiendo... ' + percent + '%');
                }
            });

            xhr.addEventListener('load', function() {
                log('Respuesta del servidor: ' + xhr.responseText);
                if (xhr.status === 200) {
                    log('✅ Actualizaci&oacute;n exitosa. Redirigiendo a la p&aacute;gina principal...');
                    setTimeout(() => { window.location.href = '/'; }, 3000);
                } else {
                    log('❌ Error durante la actualizaci&oacute;n (c&oacute;digo ' + xhr.status + ')');
                }
            });

            xhr.addEventListener('error', function() {
                log('❌ Error de red o conexi&oacute;n perdida.');
            });

            xhr.addEventListener('timeout', function() {
                log('❌ Tiempo de espera agotado. La subida no se complet&oacute;.');
            });

            xhr.addEventListener('abort', function() {
                log('❌ Subida abortada.');
            });

            const formData = new FormData();
            formData.append('firmware', file);
            xhr.send(formData);
        }
    </script>
</body>
</html>
)rawliteral";
  server.send(200, "text/html", html);
}

// Maneja la subida del archivo (llamada durante el POST)
void handleUpload() {
  if (!server.authenticate(OTA_USER, OTA_PASS)) {
    return server.requestAuthentication();
  }

  HTTPUpload& upload = server.upload();
  static size_t totalWritten = 0; // Para depuración

  if (upload.status == UPLOAD_FILE_START) {
    Serial.printf("Actualizaci&oacute;n OTA iniciada: %s\n", upload.filename.c_str());
    Serial.printf("Tamaño esperado: %u bytes\n", upload.totalSize); // Puede ser 0 si no se sabe
    if (!Update.begin(UPDATE_SIZE_UNKNOWN)) {
      Update.printError(Serial);
    }
    otaResponseSent = false;
    totalWritten = 0;
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    size_t written = Update.write(upload.buf, upload.currentSize);
    if (written != upload.currentSize) {
      Update.printError(Serial);
    } else {
      totalWritten += written;
      Serial.printf("Escritos %u bytes (total %u)\n", upload.currentSize, totalWritten);
    }
  } else if (upload.status == UPLOAD_FILE_END) {
    if (Update.end(true)) {
      Serial.printf("Actualizaci&oacute;n exitosa! Tama&ntilde;o total: %u bytes\n", totalWritten);
      if (!otaResponseSent) {
        server.sendHeader("Connection", "close");
        server.send(200, "text/plain", "Actualizaci&oacute;n completada. Reiniciando...");
        otaResponseSent = true;
        delay(1000);
        ESP.restart();
      }
    } else {
      Update.printError(Serial);
      if (!otaResponseSent) {
        server.send(500, "text/plain", "Error en la actualizaci&oacute;n");
        otaResponseSent = true;
      }
    }
  } else if (upload.status == UPLOAD_FILE_ABORTED) {
    Update.abort();
    Serial.println("Actualizaci&oacute;n abortada");
    if (!otaResponseSent) {
      server.send(500, "text/plain", "Actualizaci&oacute;n abortada");
      otaResponseSent = true;
    }
  }
}

// Maneja la petición POST (se llama al inicio, antes de la subida)
void handleUpdatePost() {
  if (!server.authenticate(OTA_USER, OTA_PASS)) {
    return server.requestAuthentication();
  }
  // No hacer nada más, la respuesta se enviará en handleUpload al finalizar
}

//==============================================================================
// SETUP
//==============================================================================
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\nIniciando ESP32 Relay Controller");

  pinMode(DATA_PIN, OUTPUT);
  pinMode(CLOCK_PIN, OUTPUT);
  pinMode(LATCH_PIN, OUTPUT);
  pinMode(OE_PIN, OUTPUT);
  digitalWrite(OE_PIN, LOW);

  for (int i = 0; i < 16; i++) relayStates[i] = false;
  actualizarRegistros();

  Serial.print("Conectando a ");
  Serial.println(ssid);
  WiFi.begin(ssid, password);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nWiFi conectado");
  Serial.print("Direcci&oacute;n IP: ");
  Serial.println(WiFi.localIP());

  server.on("/", handleRoot);
  server.on("/update", HTTP_GET, handleUpdateGet);
  server.on("/update", HTTP_POST, handleUpdatePost, handleUpload);

  server.onNotFound([]() {
    String uri = server.uri();
    if (uri.startsWith("/device/")) {
      handleDevice();
    } else {
      server.send(404, "text/plain", "P&aacute;gina no encontrada");
    }
  });

  server.begin();
  Serial.println("Servidor web iniciado");
}

//==============================================================================
// LOOP
//==============================================================================
void loop() {
  server.handleClient();
  delay(2);
}
